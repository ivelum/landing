<div id="inline-bot-root"></div>

<script>
  (function () {
    var ORGANIZATION_ID = 'd0b90198-ed39-72a4-c676-551bc4a3251d';
    var ORGANIZATION_NAME = 'Ivelum';
    var API_URL = 'https://app.flexpressai.com/api';

    // Optional: Try to get values from URL parameters if available (for flexibility)
    try {
      var urlParams = new URLSearchParams(window.location.search);
      var urlOrgId = urlParams.get('organizationId');
      var urlOrgName = urlParams.get('organizationName');
      var urlApiUrl = urlParams.get('apiUrl');

      if (urlOrgId) ORGANIZATION_ID = urlOrgId;
      if (urlOrgName) ORGANIZATION_NAME = urlOrgName;
      if (urlApiUrl) API_URL = urlApiUrl;
    } catch (e) {
      // URL parameter parsing failed, use hardcoded values
      console.log('Using hardcoded configuration values');
    }

    // Widget state
    var messages = [];
    var isLoading = false;
    var root = null;
    var shouldAutoScroll = true;
    var userHasScrolled = false;
    var currentScrollTop = 0;
    var scrollListenerAdded = false;
    var fixedMessagesHeightPx = null;

    // Initialize widget when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initInlineBotWidget);
    } else {
      initInlineBotWidget();
    }

    function initInlineBotWidget() {
      root = document.getElementById('inline-bot-root');
      if (!root) {
        console.warn('Inline Bot Widget: Could not find #inline-bot-root element');
        return;
      }

      createWidget();
      render();
    }

    function createWidget() {
      // Create the widget inside the root element
      var widget = document.createElement('div');
      widget.className = 'inline-bot-widget';
      root.appendChild(widget);

      // Update root reference to point to the actual widget
      root = widget;

      // Organization header
      if (ORGANIZATION_NAME) {
        var header = document.createElement('div');
        header.className = 'inline-bot-header';
        header.textContent = ORGANIZATION_NAME + " Bot";
        root.appendChild(header);
      }
    }

    function render() {
      if (!root) return;

      // Save current scroll position if user has scrolled
      var existingContainer = root.querySelector('.inline-bot-messages');
      if (existingContainer && userHasScrolled) {
        currentScrollTop = existingContainer.scrollTop;
      }

      // Only clear and rebuild if this is the first render
      if (!root.querySelector('.inline-bot-messages')) {
        // Preserve the header if it exists
        var existingHeader = root.querySelector('.inline-bot-header');
        root.innerHTML = '';

        // Re-add the header if it existed
        if (existingHeader) {
          root.appendChild(existingHeader);
        }
      } else {
        // For subsequent renders, just update the messages container
        var existingMessagesContainer = root.querySelector('.inline-bot-messages');
        if (existingMessagesContainer) {
          updateMessagesOnly(existingMessagesContainer);
          updateSendButtonState();
          smartScroll();
          return;
        }
      }

      // Create widget structure if needed
      if (!root.querySelector('.inline-bot-messages')) {
        initializeWidget();
      }

      var messagesContainer = root.querySelector('.inline-bot-messages');
      if (!messagesContainer) return;

      // Restore scroll position if user had scrolled
      if (userHasScrolled && currentScrollTop > 0) {
        setTimeout(function () {
          messagesContainer.scrollTop = currentScrollTop;
        }, 10);
      }

      // Only update messages content, don't rebuild everything
      messagesContainer.innerHTML = '';

      if (messages.length === 0) {
        var welcomeMsg = document.createElement('div');
        welcomeMsg.className = 'inline-bot-welcome-message';
        welcomeMsg.textContent = 'What you\'d like to learn about ivelum?';
        messagesContainer.appendChild(welcomeMsg);
      } else {
        messages.forEach(function (msg, index) {
          var msgEl = document.createElement('div');
          msgEl.className = 'inline-bot-message ' + msg.type + (msg.isError ? ' error' : '');

          var content = document.createElement('div');
          content.className = 'inline-bot-message-content';

          // Show typing indicator for last bot message when loading
          if (msg.type === 'bot' && index === messages.length - 1 && isLoading && !msg.content) {
            var typingIndicator = document.createElement('div');
            typingIndicator.className = 'inline-bot-typing-indicator';
            typingIndicator.innerHTML = '<span></span><span></span><span></span>';
            content.appendChild(typingIndicator);
          } else {
            content.innerHTML = formatMessageContent(msg.content || '', msg.references);
          }

          msgEl.appendChild(content);

          // Add references section for bot messages (only after streaming completes)
          if (msg.type === 'bot' && msg.references && msg.references.length > 0 && !(index === messages.length - 1 && isLoading)) {
            var referencesSection = document.createElement('div');
            referencesSection.className = 'inline-bot-references';

            var referencesTitle = document.createElement('strong');
            referencesTitle.textContent = 'Related:';
            referencesSection.appendChild(referencesTitle);

            var referencesList = document.createElement('ol');

            var maxVisible = 2;
            var hasMore = msg.references.length > maxVisible;

            // Show first 2 references
            msg.references.slice(0, maxVisible).forEach(function (ref) {
              var listItem = document.createElement('li');

              var anchor = document.createElement('a');
              anchor.href = ref;
              anchor.target = '_blank';
              anchor.rel = 'noopener noreferrer';
              anchor.textContent = ref;


              listItem.appendChild(anchor);
              referencesList.appendChild(listItem);
            });

            // Add "More..." link if there are additional references
            if (hasMore) {
              var moreItem = document.createElement('li');

              var moreLink = document.createElement('a');
              moreLink.href = '#';
              moreLink.className = 'more-link';
              moreLink.textContent = 'More... (' + (msg.references.length - maxVisible) + ' additional)';


              moreLink.addEventListener('click', function (e) {
                e.preventDefault();

                // Remove the "More..." item
                referencesList.removeChild(moreItem);

                // Add remaining references
                msg.references.slice(maxVisible).forEach(function (ref) {
                  var listItem = document.createElement('li');

                  var anchor = document.createElement('a');
                  anchor.href = ref;
                  anchor.target = '_blank';
                  anchor.rel = 'noopener noreferrer';
                  anchor.textContent = ref;
                  anchor.style.cssText = '\
                                    color: #667eea;\
                                    text-decoration: none;\
                                    word-break: break-all;';

                  anchor.addEventListener('mouseenter', function () {
                    this.style.textDecoration = 'underline';
                  });

                  anchor.addEventListener('mouseleave', function () {
                    this.style.textDecoration = 'none';
                  });

                  listItem.appendChild(anchor);
                  referencesList.appendChild(listItem);
                });
              });

              moreItem.appendChild(moreLink);
              referencesList.appendChild(moreItem);
            }

            referencesSection.appendChild(referencesList);
            content.appendChild(referencesSection);
          }

          msgEl.appendChild(content);
          messagesContainer.appendChild(msgEl);
        });
      }

      // Update send button state
      var sendBtn = root.querySelector('.inline-bot-send-button');
      if (sendBtn) {
        sendBtn.disabled = isLoading;
      }

      smartScroll();
    }

    function initializeWidget() {
      // Preserve the header if it exists
      var existingHeader = root.querySelector('.inline-bot-header');
      root.innerHTML = '';

      // Re-add the header if it existed
      if (existingHeader) {
        root.appendChild(existingHeader);
      }

      // Messages container
      var messagesContainer = document.createElement('div');
      messagesContainer.className = 'inline-bot-messages';

      // Add scroll event listener only once with better user scroll detection
      var lastScrollTop = messagesContainer.scrollTop;
      var scrollTimeout = null;

      messagesContainer.addEventListener('scroll', function () {
        var container = this;
        var currentScrollTop = container.scrollTop;
        var threshold = 50; // pixels from bottom
        var distanceFromBottom = container.scrollHeight - container.scrollTop - container.clientHeight;

        // Clear previous timeout
        if (scrollTimeout) {
          clearTimeout(scrollTimeout);
        }

        // Only consider it user scrolling if they moved significantly and it's not at bottom
        if (Math.abs(currentScrollTop - lastScrollTop) > 5 && distanceFromBottom > threshold) {
          userHasScrolled = true;
          shouldAutoScroll = false;

          // Reset auto-scroll after user stops scrolling for 2 seconds
          scrollTimeout = setTimeout(function () {
            if (distanceFromBottom <= threshold) {
              userHasScrolled = false;
              shouldAutoScroll = true;
            }
          }, 2000);
        } else if (distanceFromBottom <= threshold) {
          // User scrolled back to bottom
          userHasScrolled = false;
          shouldAutoScroll = true;
        }

        lastScrollTop = currentScrollTop;
      });

      root.appendChild(messagesContainer);

      // Input container
      var inputContainer = document.createElement('div');
      inputContainer.className = 'inline-bot-input-container';

      var textarea = document.createElement('textarea');
      textarea.className = 'inline-bot-input auto-resize-textarea';
      textarea.placeholder = 'Type your message...';
      textarea.rows = 1;

      // ScrollHeight-based resize to avoid jitter and preserve single-line height
      function resizeTextarea(el) {
        var minHeight = 52;
        var maxHeight = 120;
        el.style.height = 'auto';
        var newHeight = Math.min(Math.max(el.scrollHeight, minHeight), maxHeight);
        el.style.height = newHeight + 'px'; // Keep dynamic height for functionality
      }

      // Initial sizing
      resizeTextarea(textarea);

      textarea.addEventListener('input', function () {
        resizeTextarea(this);
      });

      // Handle Enter key
      textarea.addEventListener('keydown', function (e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });

      var sendBtn = document.createElement('button');
      sendBtn.className = 'inline-bot-send-button';
      sendBtn.innerHTML = '→';
      sendBtn.disabled = isLoading;
      sendBtn.addEventListener('click', sendMessage);

      inputContainer.appendChild(textarea);
      inputContainer.appendChild(sendBtn);
      root.appendChild(inputContainer);

      // Lock current messages container height (fixed chat height like default state)
      // Do this on next frame to ensure layout is finalized
      if (fixedMessagesHeightPx === null) {
        requestAnimationFrame(function () {
          var container = root.querySelector('.inline-bot-messages');
          if (!container) return;
          fixedMessagesHeightPx = container.clientHeight;
          if (fixedMessagesHeightPx > 0) {
            // Set height and flex via CSS classes instead of inline styles
            container.style.height = fixedMessagesHeightPx + 'px'; // Keep for dynamic functionality
            container.style.flex = 'none'; // Keep for dynamic functionality
          }

          // Keep pinned to bottom when content grows (streaming)
          try {
            var mo = new MutationObserver(function () {
              if (shouldAutoScroll && !userHasScrolled) {
                container.scrollTop = container.scrollHeight;
              }
            });
            mo.observe(container, {childList: true, subtree: true, characterData: true});
          } catch (e) {}

          if (window.ResizeObserver) {
            try {
              var ro = new ResizeObserver(function () {
                if (shouldAutoScroll && !userHasScrolled) {
                  container.scrollTop = container.scrollHeight;
                }
              });
              ro.observe(container);
            } catch (e) {}
          }

          // Nudge scroll after images/fonts load to account for late layout shifts
          try {
            container.addEventListener('load', function (ev) {
              var target = ev.target || {};
              if (target.tagName === 'IMG' && shouldAutoScroll && !userHasScrolled) {
                container.scrollTop = container.scrollHeight;
              }
            }, true);
          } catch (e) {}

          try {
            if (document.fonts && document.fonts.ready) {
              document.fonts.ready.then(function () {
                if (shouldAutoScroll && !userHasScrolled) {
                  container.scrollTop = container.scrollHeight;
                }
              });
            }
          } catch (e) {}

          // Ensure initial position is bottom
          container.scrollTop = container.scrollHeight;
        });
      }
    }

    function sendMessage() {
      var textarea = root.querySelector('.inline-bot-input');
      var message = textarea.value.trim();
      if (!message || isLoading) return;

      // Add user message
      messages.push({type: 'user', content: message});
      textarea.value = '';

      // Add empty bot message for streaming
      var lastBotMessage = {type: 'bot', content: ''};
      messages.push(lastBotMessage);

      isLoading = true;

      // Enable auto-scroll for new message
      shouldAutoScroll = true;
      userHasScrolled = false;

      render();

      // Scroll to bottom when new question is asked
      scrollToBottom();
      // Send to API using POST request like other widgets
      var headers = {
        'Content-Type': 'application/json',
        'Accept': 'text/event-stream'
      };

      fetch(API_URL + '/companion-service/v1/organizations/' + ORGANIZATION_ID + '/conversations/stream', {
        method: 'POST',
        headers: headers,
        body: JSON.stringify({query: message, scope: 'chat'})
      }).then(function (res) {
        if (!res.ok) throw new Error('HTTP ' + res.status);
        var reader = res.body.getReader();
        var decoder = new TextDecoder();
        var buffer = '';

        function readChunk() {
          return reader.read().then(function (result) {
            var done = result.done;
            var value = result.value;

            if (done) {
              isLoading = false;
              render();
              return;
            }

            var chunk = decoder.decode(value, {stream: true});
            buffer += chunk;
            var lines = buffer.split('\n');
            buffer = lines.pop() || ''; // Keep incomplete line in buffer

            for (var i = 0; i < lines.length; i++) {
              var line = lines[i];
              if (line.startsWith('data:')) {
                try {
                  var jsonStr = line.substring(5).trim();
                  if (jsonStr && jsonStr !== '[DONE]') {
                    var data = JSON.parse(jsonStr);

                    // Check for errors using the same logic as Search and Companion Bot widgets
                    if (data.isError || data.error) {
                      lastBotMessage.content = data.error || data.message || 'An error occurred';
                      lastBotMessage.isError = true;
                    } else if (data.response) {
                      lastBotMessage.content = data.response;
                      lastBotMessage.references = data.references;
                    }

                    render();
                  }
                } catch (e) {
                  console.error('Error parsing SSE data:', e);
                }
              }
            }

            return readChunk();
          });
        }

        return readChunk();
      }).catch(function (error) {
        console.error('Fetch error:', error);
        isLoading = false;
        if (!lastBotMessage.content) {
          lastBotMessage.content = 'Sorry, I encountered an error. Please try again.';
          lastBotMessage.isError = true;
        }
        render();
      });
    }

    function formatMessageContent(content, references) {
      if (!content) return '';
      var result = content.replace(/\n/g, '<br>');

      // Convert Context[#] to clickable links
      if (references && references.length > 0) {
        // Prepare URLs
        // Parse ["Title", "URL"] even if title contains quotes
        result = result
          // JSON-style: ["Title", "https://url"] — strict, non-greedy
          .replace(
            /\[\s*(['"])(.*?)\1\s*,\s*(?:(['"])?((?:https?:\/\/)[^\s'"\]\n]+)\3?)\s*\]/g,
            function (_match, _q1, rawTitle, _q2, rawUrl) {
              var title = rawTitle.replace(/\\(['"])/g, '$1'); // unescape quotes
              var url = rawUrl;
              return '<a href="' + url + '" target="_blank" rel="noopener noreferrer" style="color: #667eea; text-decoration: none;">' + title + '</a>';
            }
          )
          // Markdown-style: [Title](https://url)
          .replace(
            /\[([^\]]+?)\]\((https?:\/\/[^\s)]+)\)/g,
            function (_match, title, url) {
              return '<a href="' + url + '" target="_blank" rel="noopener noreferrer" style="color: #667eea; text-decoration: none;">' + title + '</a>';
            }
          );
      }

      return result;
    }

    function smartScroll() {
      var messagesContainer = root.querySelector('.inline-bot-messages');
      if (!messagesContainer) return;
      if (shouldAutoScroll && !userHasScrolled) {
        if (isLoading) {
          // During streaming, snap to bottom to avoid jitter
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        } else {
          // After completion, smooth to bottom once
          messagesContainer.scrollTo({
            top: messagesContainer.scrollHeight,
            behavior: 'smooth'
          });
        }
      }
    }

    function scrollToBottom() {
      // Force scroll to bottom (for new messages)
      var messagesContainer = root.querySelector('.inline-bot-messages');
      if (messagesContainer) {
        if (isLoading) {
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        } else {
          messagesContainer.scrollTo({
            top: messagesContainer.scrollHeight,
            behavior: 'smooth'
          });
        }
      }
    }

    function updateMessagesOnly(messagesContainer) {
      messagesContainer.innerHTML = '';

      if (messages.length === 0) {
        var welcomeMsg = document.createElement('div');
        welcomeMsg.className = 'inline-bot-welcome-message';
        welcomeMsg.textContent = 'Hello! How can I help you today?';
        messagesContainer.appendChild(welcomeMsg);
      } else {
        messages.forEach(function (msg, index) {
          var msgEl = document.createElement('div');
          msgEl.className = 'inline-bot-message ' + msg.type + (msg.isError ? ' error' : '');

          var content = document.createElement('div');
          content.className = 'inline-bot-message-content';

          // Show typing indicator for last bot message when loading
          if (msg.type === 'bot' && index === messages.length - 1 && isLoading && !msg.content) {
            var typingIndicator = document.createElement('div');
            typingIndicator.className = 'inline-bot-typing-indicator';
            typingIndicator.innerHTML = '<span></span><span></span><span></span>';
            content.appendChild(typingIndicator);
          } else {
            content.innerHTML = formatMessageContent(msg.content || '', msg.references);
          }

          msgEl.appendChild(content);

          // Add references section for bot messages (only after streaming completes)
          if (msg.type === 'bot' && msg.references && msg.references.length > 0 && !(index === messages.length - 1 && isLoading)) {
            var referencesSection = document.createElement('div');
            referencesSection.className = 'inline-bot-references';

            var referencesTitle = document.createElement('strong');
            referencesTitle.textContent = 'Related:';
            referencesSection.appendChild(referencesTitle);

            var referencesList = document.createElement('ol');

            var maxVisible = 2;
            var hasMore = msg.references.length > maxVisible;

            // Show first 2 references
            msg.references.slice(0, maxVisible).forEach(function (ref) {
              var listItem = document.createElement('li');

              var anchor = document.createElement('a');
              anchor.href = ref;
              anchor.target = '_blank';
              anchor.rel = 'noopener noreferrer';
              anchor.textContent = ref;


              listItem.appendChild(anchor);
              referencesList.appendChild(listItem);
            });

            // Add "More..." link if there are additional references
            if (hasMore) {
              var moreItem = document.createElement('li');

              var moreLink = document.createElement('a');
              moreLink.href = '#';
              moreLink.textContent = 'More... (' + (msg.references.length - maxVisible) + ' additional)';


              moreLink.addEventListener('click', function (e) {
                e.preventDefault();

                // Remove the "More..." item
                referencesList.removeChild(moreItem);

                // Add remaining references
                msg.references.slice(maxVisible).forEach(function (ref) {
                  var listItem = document.createElement('li');

                  var anchor = document.createElement('a');
                  anchor.href = ref;
                  anchor.target = '_blank';
                  anchor.rel = 'noopener noreferrer';
                  anchor.textContent = ref;
                  anchor.style.cssText = '\
                                    text-decoration: none;\
                                    word-break: break-all;';

                  anchor.addEventListener('mouseenter', function () {
                    this.style.textDecoration = 'underline';
                  });

                  anchor.addEventListener('mouseleave', function () {
                    this.style.textDecoration = 'none';
                  });

                  listItem.appendChild(anchor);
                  referencesList.appendChild(listItem);
                });
              });

              moreItem.appendChild(moreLink);
              referencesList.appendChild(moreItem);
            }

            referencesSection.appendChild(referencesList);
            content.appendChild(referencesSection);
          }

          msgEl.appendChild(content);
          messagesContainer.appendChild(msgEl);
        });
      }
    }

    function updateSendButtonState() {
      var sendBtn = root.querySelector('.inline-bot-send-button');
      if (sendBtn) {
        sendBtn.disabled = isLoading;
        // Use CSS classes instead of inline styles
        if (isLoading) {
          sendBtn.classList.add('disabled');
        } else {
          sendBtn.classList.remove('disabled');
        }
      }
    }
  })();
</script>
